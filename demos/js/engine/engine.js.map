{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","source/frontend/js/engine/engine.js","source/frontend/js/engine/vector2d.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"engine.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// # engine.js\n\n// This is the game engine's [Browserify](https://github.com/substack/node-browserify) bundle file.\n//\n// The various game engine libraries are bundled here so that they can be used by games.\n\n// **vector2d**\n//\n// This is our 2 dimensional vector library.\nvar vector2d = require('./vector2d.js');\n","// # vector2d.js\n\n// **vector2d** is a class that handles 2 dimension vector math.\n\n// **tolerance**\n//\n// any number that is less than tolerance will be reduced to 0\nvar tolerance = 0.001;\n\n// **setSmallNumbersToZero()**\n//\n// This is a private function that helps to convert\n// numbers that are below **tolerance** in magnitude\n// to 0.\nfunction setSmallNumbersToZero(number) {\n  return (Math.abs(number) > tolerance) ? number : 0;\n}\n\n// ### vector2d\n\n// **vector2d constructor**\n//\n// Constructs and returns a new vector object.\n//\n// There are two valid ways to call `vector2d`\n// * `var vector1 = new vector2d(1, 2);\n// * `var vector2 = vector2d(1, 2);\nfunction vector2d(x, y) {\n  if (!(this instanceof vector2d)) return new vector2d(x, y);\n\n  this.x = setSmallNumbersToZero(x);\n  this.y = setSmallNumbersToZero(y);\n}\n\nvector2d.tolerance              = tolerance;\nvector2d.setSmallNumbersToZero  = setSmallNumbersToZero;\n\n// **prototype initialization**\nvector2d.prototype = {};\n\n// **vector2d.magnitude()**\n//\n// returns the magnitude (length) of the current vector\nvector2d.prototype.magnitude = function() {\n  return Math.sqrt( (this.x * this.x) + (this.y * this.y) );\n};\n\n// **vector2d.scale()**\n//\n// multiplies all components of the vector by **scalingFactor**,\n// which multiplies the vector's magnitude by **scalingFactor** \n// as well.\n//\n// returns itself for chaining.\nvector2d.prototype.scale = function(scalingFactor) {\n  scalingFactor = setSmallNumbersToZero(scalingFactor);\n\n  this.x = this.x * scalingFactor;\n  this.y = this.y * scalingFactor;\n\n  return this;\n};\n\n// **vector2d.normalize()**\n//\n// set this vector's magnitude to 1.  Returns itself for chaining.\nvector2d.prototype.normalize = function() {\n  var magnitude = this.magnitude();\n\n  if (magnitude <= tolerance) {\n    magnitude = 1;\n  }\n\n  return this.scale(1 / magnitude);\n};\n\n// **vector2d.reverse()** \n//\n// returns vector with the same magnitude (length) as\n// the current vector, but in the oposite direction.\nvector2d.prototype.reverse = function() {\n  this.x = -this.x;\n  this.y = -this.y;\n\n  return this;\n};\n\n// **vector2d.add()**\n//\n// adds a vector to the current vector.\n// returns itself for chaining.\nvector2d.prototype.add = function(vector) {\n  this.x = this.x + vector.x;\n  this.y = this.y + vector.y;\n\n  return this;\n};\n\n// **vector2d.dotProduct()**\n//\n// returns the dot product of two vectors.\n//\n// for vectors **u** and **v**, \n// u.dotProduct(v) === u.magnitude() * v.magnitude() * cos(angleBetweenTheVectors).\nvector2d.prototype.dotProduct = function(vector) {\n  return (this.x * vector.x) + (this.y * vector.y);\n};\n\nmodule.exports = vector2d;"]}